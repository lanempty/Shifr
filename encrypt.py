from textwrap import wrap


def Check(key, count):  # функция,проверяющая на равенство размер ключа и символа
    L = []  # создаем пустой список
    for i in range(count):  # для каждого числа от 0 до count
        L.append(str(i))  # добавляем в список строковое представление этого числа
    key = list(key)  # преобразуем строку ключа в список
    return sorted(key) == sorted(L)  # возвращаем результат сравнения отсортированного списка ключа и списка символов



def encryption(size, key, line, count):
    # Функция принимает параметры size - тип блока, key - ключ, line - содержание блока, count - длина размера блока
    if size == 'символ':
        # Если тип блока - символ, то выполняется следующее:
        if len(key) == len(line):
            # Если длина ключа равна длине строки, то:
            line_new = [""] * len(line)  # Создаётся список line_new с пустыми элементами
            j = 0
            for i in key:
                # Проходим по всем элементам ключа
                line_new[int(i)] = line[j]  # В соответствующий элемент списка line_new записывается значение из строки
                j += 1
            return ''.join(line_new)  # Функция возвращает список line_new в виде строки
        elif len(key) < len(line):
            # Если длина ключа меньше длины строки, то:
            line_div = wrap(line, len(key))  # строка делится на блоки длины ключа
            line_new = []  # Создаётся пустой список line_new
            while (len(line_div[-1]) < len(key)):
                # Добавляются нули, пока длина последнего блока не будет равна длине ключа
                line_div[-1] += '0'
            for i in line_div:
                # Для каждого блока из списка line_div
                line_new.append(encryption('символ', key, i, count)) # добавляет в новый список зашифрованный символ
            return ''.join(line_new) # возвращает зашифрованную строку
    elif size == 'группа символов':
        # Если тип блока - группа символов, то выполняется следующее:
        line_div = wrap(line, 2)  # строка разбивается на блоки по 2 символа
        line_new = [""] * len(line_div)  # Создаётся список line_new с пустыми элементами
        j = 0
        for i in key:
            # Проходим по всем элементам ключа
            line_new[int(i)] = line_div[j]  # В соответствующий элемент списка line_new записывается значение из блока строки
            j += 1
        return ''.join(line_new)  # Функция возвращает список line_new в виде строки
    elif size == 'слово':
        # Если тип блока - слово, то выполняется следующее:
        line_div = line.split(' ')  # Строка разбивается на слова по пробелам
        line_new = [""] * len(line_div)  # Создаётся список line_new с пустыми элементами
        j = 0
        for i in key:
            # Проходим по всем элементам ключа
            line_new[int(i)] = line_div[j] + " "  # В соответствующий элемент списка line_new записывается значение из слова строки, добавляется пробел
            j += 1
        return ''.join(line_new)  # Функция возвращает список line_new в виде строки
