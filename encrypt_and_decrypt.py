from textwrap import wrap


def Check(key, count):  # функция,проверяющая на равенство размер ключа и символа
    L = []  # создаем пустой список
    for i in range(count):  # для каждого числа от 0 до count
        L.append(str(i))  # добавляем в список строковое представление этого числа
    key = list(key)  # преобразуем строку ключа в список
    return sorted(key) == sorted(L)  # возвращаем результат сравнения отсортированного списка ключа и списка символов



def encryption(size, key, line, count):
    # Функция принимает параметры size - тип блока, key - ключ, line - содержание блока, count - длина размера блока
    if size == 'символ':
        # Если тип блока - символ, то выполняется следующее:
        if len(key) == len(line):
            # Если длина ключа равна длине строки, то:
            line_new = [""] * len(line)  # Создаётся список line_new с пустыми элементами
            j = 0
            for i in key:
                # Проходим по всем элементам ключа
                line_new[int(i)] = line[j]  # В соответствующий элемент списка line_new записывается значение из строки
                j += 1
            return ''.join(line_new)  # Функция возвращает список line_new в виде строки
        elif len(key) < len(line):
            # Если длина ключа меньше длины строки, то:
            line_div = wrap(line, len(key))  # строка делится на блоки длины ключа
            line_new = []  # Создаётся пустой список line_new
            while (len(line_div[-1]) < len(key)):
                # Добавляются нули, пока длина последнего блока не будет равна длине ключа
                line_div[-1] += '0'
            for i in line_div:
                # Для каждого блока из списка line_div
                line_new.append(encryption('символ', key, i, count)) # добавляет в новый список зашифрованный символ
            return ''.join(line_new) # возвращает зашифрованную строку
    elif size == 'группа символов':
        # Если тип блока - группа символов, то выполняется следующее:
        line_div = wrap(line, 2)  # строка разбивается на блоки по 2 символа
        line_new = [""] * len(line_div)  # Создаётся список line_new с пустыми элементами
        j = 0
        for i in key:
            # Проходим по всем элементам ключа
            line_new[int(i)] = line_div[j]  # В соответствующий элемент списка line_new записывается значение из блока строки
            j += 1
        return ''.join(line_new)  # Функция возвращает список line_new в виде строки
    elif size == 'слово':
        # Если тип блока - слово, то выполняется следующее:
        line_div = line.split(' ')  # Строка разбивается на слова по пробелам
        line_new = [""] * len(line_div)  # Создаётся список line_new с пустыми элементами
        j = 0
        for i in key:
            # Проходим по всем элементам ключа
            line_new[int(i)] = line_div[j] + " "  # В соответствующий элемент списка line_new записывается значение из слова строки, добавляется пробел
            j += 1
        return ''.join(line_new)  # Функция возвращает список line_new в виде строки


def decryption(size, key, line, count): # объявление функции с 4 параметрами
    if size == 'символ': # проверка условия, если размер указан как "символ", то продолжаем выполнение функции
        key_len = len(key) # определение длины ключа
        if key_len == len(line): # проверка условия, если длина ключа равна длине строки, то продолжаем выполнение функции
            line_new = "" # инициализация пустой строки
            for i in key: # для каждого индекса i из ключа выполнить следующий блок
                line_new += line[int(i)] # добавляем в новую строку символ из строки line с индексом i, который был преобразован к целочисленному типу
            return line_new # возвращаем новую строку, полученную в результате выполнения цикла for
        elif key_len < len(line):  # проверка условия, если длина ключа меньше длины строки, то продолжаем выполнение функции
            line_div = wrap(line, key_len)  # разбиваем строку на части длиной, равной длине ключа
            line_new = ""  # инициализация пустой строки
            while (len(line_div[-1]) < key_len):  # цикл, который добавляет нулевые символы в последнюю строку line_div, если ее длина меньше длины ключа
                line_div[-1] += '\0'
            for i in line_div:  # для каждой части строки выполнить следующий блок
                line_new += decryption('символ', key, i, count)  # вызываем функцию дешифровки для каждой части строки
            i = len(line_new) - 1  # устанавливаем счетчик i на последний символ новой строки
            while (line_new[i] == '0'):  # цикл, который удаляет нулевые символы в конце новой строки
                line_new = line_new[:len(line_new) - 1]
                i -= 1
            return line_new  # возвращаем новую строку, полученную в результате выполнения цикла for
    elif size == 'группа символов':  # проверка условия, если размер шифруемого сообщения - "группа символов", то продолжаем выполнение функции
        line_div = wrap(line, count)  # разбиваем строку на группы символов заданной длины
        line_new = ""  # инициализация пустой строки
        for i in key:  # для каждого элемента ключа выполнить следующий блок
            line_new += line_div[int(i)]  # добавляем в строку новый символ, взятый из строки line_div по индексу i
        return line_new  # возвращаем новую строку, полученную в результате выполнения цикла for
    elif size == 'слово':  # проверка условия, если размер шифруемого сообщения - "слово", то продолжаем выполнение функции
        line_div = line.split(' ')  # разбиваем строку на слова
        line_new = ""  # инициализация пустой строки
        for i in key:  # для каждого элемента ключа выполнить следующий блок
            line_new += line_div[int(i)] + " "  # добавляем в строку новое слово, взятое из строки line_div по индексу i, и добавляем после него пробел
        return line_new  # возвращаем новую строку, полученную в результате выполнения цикла for


change = input("Введите действие(шифрование или дешифрование) ")
size = input('Введите содержание блока(символ,группа символов,слово) ')
symbol = input("Введите строку для шифрования: ")
# key = input("Введите ключ: ")
if size == 'символ':
    key = input("Введите ключ: ")
    if change == 'шифрование':
        print("Результат шифрования: ", encryption(size, key, symbol, 0))
    elif change == 'дешифрование':
        print("Результат расшифровки: ", decryption(size, key, symbol, 0))

elif size == 'группа символов':  # реализовано только длина размера блока 2
    q = int(input("Введите размер группы символов(сколько символов в 1 группе): "))
    key = input("Введите ключ: ")
    while (len(symbol) % q != 0): # Проверка на кратность с количеством символов
        print("Размер группы должен быть кратен кол-ву символов в строке (" + str(len(symbol)) + ")")
        q = int(input("Введите ещё раз: "))
    while (Check(key, len(symbol) // q) == False): # Проверка на кратность с количеством групп
        print("Ключ должен быть перестановкой чисел от 0 до i, где i - кол-во групп (" + str(len(symbol) // q) + ")")
        key = input("Введите ещё раз: ")
    if change == 'шифрование':
        print("Результат шифрования: ", encryption(size, key, symbol, q))
    elif change == 'дешифрование':
        print("Результат расшифровки: ", decryption(size, key, symbol, q))

elif size == 'слово':
    key = input("Введите ключ: ")
    while (Check(key, len(symbol.split(' '))) == False):
        print(
            "Ключ должен быть перестановкой чисел от 0 до i, где i - кол-во слов (" + str(len(symbol.split(' '))) + ")")
        key = input("Введите ещё раз: ")
    if change == 'шифрование':
        print("Результат шифрования: ", encryption(size, key, symbol, 0))
    elif change == 'дешифрование':
        print("Результат расшифровки: ", decryption(size, key, symbol, 0))
else:
    print("Вы ввели неправильное значение")
